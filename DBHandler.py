# -*- coding: utf-8 -*-
"""An abstract class, combining different DB handlers
Combines different DB types and can be used by other tools.

For now, the following DB types are available:
    - SQLite3
"""
import os
import sqlite3
import sys
from sqlite3 import OperationalError

from FileReader import FileReader


class DBHandler:
    """Create a connection to any given database format via '.connect'
    Usage:

        db_handler = DBHandler()
        db_handler_connection = db_handler.connect('sqlite3')
    """
    def __init__(self, db_file_path='AUTOGENERATED.db', db_type='sqlite3'):
        """Init for the DBHandler class

        :param db_file_path:
            The path and name of your database file
        :param db_type:
            The type of your database, defaults to 'sqlite3'
        """
        self.db_types = {
            'sqlite3': sqlite3.connect(db_file_path),
        }
        self.db_file_path = db_file_path
        self.db_type = db_type.lower()

        self.job_check = {
            'init_db_done': False,
            'create_db_done': False,
        }

        self.known_datatypes = {}

    @property
    def create_db(self):
        """Creates a file according to the given db file path
        If a directory is provided, a default file will be created and initialized.
        """
        if os.path.isdir(self.db_file_path):
            self.db_file_path = os.path.join(self.db_file_path, "AUTOGENERATED.db")

        FileReader.read_file(self.db_file_path, "w+")

        self.job_check['create_db_done'] = True
        return self.db_file_path

    def init_database(self, sql_schema=None, sep=';'):
        """
        Init. your tables using any list of commands

        :param sql_schema:
            Any SQL-Schema seperated by ';', defaults to None
            The seperator can be changed via sep='x'
        :param sql_schema: str, optional
        :param sep: Seperation type, defaults to ';'
        """
        with self.connection as cursor:
            DBHandler._init_database_helper(cursor, sql_schema, sep)

        self.job_check['init_db_done'] = True

    @staticmethod
    def _init_database_helper(cursor, commands, sep):
        commands = commands.split(sep)
        for command in commands:
            try:
                cursor.execute(command)
            except OperationalError as msg:
                print(f"Command skipped: {msg}")

    @property
    def connection(self):
        """Create a connection to a given database type
        The database type given is not case sensitive

        :return: Database connection object
        :raises sqlite3.Error:
            Raises exception, if it can't connect to the SQLite3 database
        """
        try:
            return self.db_types[self.db_type]
        except sqlite3.Error as error:
            raise f"An SQLite3 Error occurred: {error}"

    def insert_to_db(self, table_name, data_to_insert):
        """Insert data into one of your tables
        It is not allowed to search, alter, delete etc. with this method

        :param table_name:
            Name of your SQL Table
        :param data_to_insert: 
            All data to insert
        :type data_to_insert:
            Dict
        :raises OperationalError:
            If insertion was not possible
        """
        if any(self.job_check.values()) is False and not os.path.isfile(self.db_file_path):
            print(f"Please initialize and create your database first!")
            sys.exit()

        data_types = ""
        querstionmarks = ""

        # Learns to connect datatypes with tables
        if table_name not in self.known_datatypes.keys():
            for data in data_to_insert.keys():
                data_types += str(data) + ", "
                querstionmarks += "?, "
            data_types = data_types[:-2]
            querstionmarks = querstionmarks[:-2]
            self.known_datatypes = {table_name: (data_types, querstionmarks)}
        else:
            data_types = self.known_datatypes[table_name][0]
            querstionmarks = self.known_datatypes[table_name][1]

        with self.connection as cursor:
            try:
                cursor.execute(
                    "INSERT INTO " + table_name + "(" + data_types + ") VALUES (" + querstionmarks +")",
                    tuple(data_to_insert.values()))
                cursor.commit()
            except OperationalError:
                print(f"Could not insert to {table_name}: {data_types} - {list(data_to_insert.values())}")
            except sqlite3.IntegrityError as ie:
                print(f"{ie} in table {table_name} at {data_types} - {list(data_to_insert.values())}")
